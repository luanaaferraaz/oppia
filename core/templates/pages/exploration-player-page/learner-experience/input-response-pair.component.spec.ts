// Copyright 2021 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Unit tests for LearnerAnswerInfoCard
 */

import {NO_ERRORS_SCHEMA} from '@angular/core';
import {NgbModalRef} from '@ng-bootstrap/ng-bootstrap';
import {
  async,
  ComponentFixture,
  TestBed,
  fakeAsync,
  tick,
} from '@angular/core/testing';
import {BackgroundMaskService} from 'services/stateful/background-mask.service';
import {ExplorationHtmlFormatterService} from 'services/exploration-html-formatter.service';
import {HttpClientTestingModule} from '@angular/common/http/testing';
import {PlayerTranscriptService} from '../services/player-transcript.service';
import {InputResponsePairComponent} from './input-response-pair.component';
import {MockTranslatePipe} from 'tests/unit-test-utils';
import {NgbModule} from '@ng-bootstrap/ng-bootstrap';
import {RecordedVoiceovers} from 'domain/exploration/recorded-voiceovers.model';
import {StateCard} from 'domain/state_card/state-card.model';
import {InteractionObjectFactory} from 'domain/exploration/InteractionObjectFactory';
import {AudioTranslationLanguageService} from '../services/audio-translation-language.service';
import {AudioTranslationManagerService} from '../services/audio-translation-manager.service';
import {AppConstants} from 'app.constants';
import {AudioPlayerService} from 'services/audio-player.service';
import {ExplorationPlayerConstants} from '../exploration-player-page.constants';
import {I18nLanguageCodeService} from 'services/i18n-language-code.service';
import {AutogeneratedAudioPlayerService} from 'services/autogenerated-audio-player.service';
import {NumberConversionService} from 'services/number-conversion.service';
import {HintsAndSolutionManagerService} from '../services/hints-and-solution-manager.service';
import {HintAndSolutionModalService} from '../services/hint-and-solution-modal.service';

describe('InputResponsePairComponent', () => {
  let component: InputResponsePairComponent;
  let fixture: ComponentFixture<InputResponsePairComponent>;
  let explorationHtmlFormatter: ExplorationHtmlFormatterService;
  let interactionObjectFactory: InteractionObjectFactory;
  let playerTranscriptService: PlayerTranscriptService;
  let audioTranslationLanguageService: AudioTranslationLanguageService;
  let audioTranslationManagerService: AudioTranslationManagerService;
  let audioPlayerService: AudioPlayerService;
  let i18nLanguageCodeService: I18nLanguageCodeService;
  let autogeneratedAudioPlayerService: AutogeneratedAudioPlayerService;
  let numberConversionService: NumberConversionService;
  let hintsAndSolutionManagerService: HintsAndSolutionManagerService;
  let hintAndSolutionModalService: HintAndSolutionModalService;

  beforeEach(async(() => {
    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule, NgbModule],
      declarations: [InputResponsePairComponent, MockTranslatePipe],
      providers: [BackgroundMaskService],
      schemas: [NO_ERRORS_SCHEMA],
    }).compileComponents();
  }));

  beforeEach(() => {
    explorationHtmlFormatter = TestBed.get(ExplorationHtmlFormatterService);
    audioPlayerService = TestBed.get(AudioPlayerService);
    playerTranscriptService = TestBed.get(PlayerTranscriptService);
    interactionObjectFactory = TestBed.get(InteractionObjectFactory);
    autogeneratedAudioPlayerService = TestBed.get(
      AutogeneratedAudioPlayerService
    );
    audioTranslationManagerService = TestBed.get(
      AudioTranslationManagerService
    );
    audioTranslationLanguageService = TestBed.get(
      AudioTranslationLanguageService
    );
    hintsAndSolutionManagerService = TestBed.inject(
      HintsAndSolutionManagerService
    );
    hintAndSolutionModalService = TestBed.inject(HintAndSolutionModalService);
    i18nLanguageCodeService = TestBed.get(I18nLanguageCodeService);
    numberConversionService = TestBed.inject(NumberConversionService);
    fixture = TestBed.createComponent(InputResponsePairComponent);
    component = fixture.componentInstance;

    spyOn(i18nLanguageCodeService, 'isCurrentLanguageRTL').and.returnValue(
      true
    );

    spyOn(playerTranscriptService, 'getCard').and.returnValue(
      StateCard.createNewCard(
        'State 2',
        '<p>Content</p>',
        '<interaction></interaction>',
        interactionObjectFactory.createFromBackendDict({
          id: 'GraphInput',
          answer_groups: [
            {
              outcome: {
                dest: 'State',
                dest_if_really_stuck: null,
                feedback: {
                  html: '',
                  content_id: 'This is a new feedback text',
                },
                refresher_exploration_id: 'test',
                missing_prerequisite_skill_id: 'test_skill_id',
                labelled_as_correct: true,
                param_changes: [],
              },
              rule_specs: [],
              training_data: [],
              tagged_skill_misconception_id: '',
            },
          ],
          default_outcome: {
            dest: 'Hola',
            dest_if_really_stuck: null,
            feedback: {
              content_id: '',
              html: '',
            },
            labelled_as_correct: true,
            param_changes: [],
            refresher_exploration_id: 'test',
            missing_prerequisite_skill_id: 'test_skill_id',
          },
          confirmed_unclassified_answers: [],
          customization_args: {
            rows: {
              value: true,
            },
            placeholder: {
              value: 1,
            },
            catchMisspellings: {
              value: false,
            },
          },
          hints: [],
          solution: {
            answer_is_exclusive: true,
            correct_answer: 'test_answer',
            explanation: {
              content_id: '2',
              html: 'test_explanation1',
            },
          },
        }),
        RecordedVoiceovers.createEmpty(),
        'content',
        audioTranslationLanguageService
      )
    );
  });

  it('should check if input response contains video rte element', () => {
    component.data = {
      learnerInput: '',
      oppiaResponse: 'oppia-noninteractive-video-response',
      isHint: true,
    };

    expect(component.isVideoRteElementPresentInResponse()).toBe(true);
  });

  it(
    'should return false if input response does not contain ' +
      'video rte element',
    () => {
      component.data = {
        learnerInput: '',
        oppiaResponse: null,
        isHint: true,
      };

      expect(component.isVideoRteElementPresentInResponse()).toBeFalse();
    }
  );

  it('should get answer html for the displayed card', () => {
    spyOn(explorationHtmlFormatter, 'getAnswerHtml').and.returnValue(
      '<p> HTML Answer </p>'
    );
    component.data = {
      learnerInput: '',
      oppiaResponse: 'oppia-noninteractive-video-response',
      isHint: true,
    };

    expect(component.getAnswerHtml()).toBe('<p> HTML Answer </p>');
  });

  it('should toggle popover when user clicks on it', () => {
    // This throws "Type '{ toggle: () => void; }' is missing the following
    // properties from type 'NgbPopover': _elementRef, _renderer, _ngZone,
    // _document, and 26 more.". We need to suppress this error because we have
    // to only test the toggle function.
    // @ts-expect-error
    component.popover = {
      toggle: () => {},
    };
    spyOn(component.popover, 'toggle');

    component.togglePopover();

    expect(component.popover.toggle).toHaveBeenCalled();
  });

  it('should get a short summary of the answer', () => {
    spyOn(explorationHtmlFormatter, 'getShortAnswerHtml').and.returnValue(
      'Short Answer'
    );
    component.data = {
      // This throws "Type '{ answerDetails: string; }' is not assignable to
      // type 'string'.". We need to suppress this error because we need to
      // store "answerDetails" to test the relevant code. This is done to
      // avoid the lint error "This test should have at least one expectation.".
      // @ts-ignore
      learnerInput: {
        answerDetails: 'Answer Details',
      },
      oppiaResponse: 'oppia-noninteractive-video-response',
      isHint: true,
    };

    expect(component.getShortAnswerHtml()).toBe('Answer Details');

    component.data = {
      learnerInput: '',
      oppiaResponse: 'oppia-noninteractive-video-response',
      isHint: true,
    };

    expect(component.getShortAnswerHtml()).toBe('Short Answer');
  });

  it('should check if the current card is at the end of the transcript', () => {
    spyOn(playerTranscriptService, 'isLastCard').and.returnValue(true);

    expect(component.isCurrentCardAtEndOfTranscript()).toBe(true);
  });

  it('should get the css class for feedback audio highlight', () => {
    spyOn(
      audioTranslationManagerService,
      'getCurrentComponentName'
    ).and.returnValue(AppConstants.COMPONENT_NAME_FEEDBACK);
    spyOn(audioPlayerService, 'isPlaying').and.returnValue(true);
    component.isLastPair = false;

    expect(component.getFeedbackAudioHighlightClass()).toBe('');

    component.isLastPair = true;

    expect(component.getFeedbackAudioHighlightClass()).toBe(
      ExplorationPlayerConstants.AUDIO_HIGHLIGHT_CSS_CLASS
    );
  });

  it(
    'should return empty css class for feedback audio highlight ' +
      'when audio player service is not playing',
    () => {
      spyOn(
        audioTranslationManagerService,
        'getCurrentComponentName'
      ).and.returnValue(AppConstants.COMPONENT_NAME_FEEDBACK);
      spyOn(audioPlayerService, 'isPlaying').and.returnValue(false);
      component.isLastPair = true;

      expect(component.getFeedbackAudioHighlightClass()).toBe('');
    }
  );

  it(
    'should return empty css class for feedback audio highlight ' +
      'when auto generated audio player service is not playing',
    () => {
      spyOn(
        audioTranslationManagerService,
        'getCurrentComponentName'
      ).and.returnValue(AppConstants.COMPONENT_NAME_FEEDBACK);
      spyOn(autogeneratedAudioPlayerService, 'isPlaying').and.returnValue(
        false
      );
      component.isLastPair = true;

      expect(component.getFeedbackAudioHighlightClass()).toBe('');
    }
  );

  it(
    'should return empty css class for feedback audio highlight ' +
      'when current component name does not match',
    () => {
      spyOn(
        audioTranslationManagerService,
        'getCurrentComponentName'
      ).and.returnValue('sample');
      spyOn(audioPlayerService, 'isPlaying').and.returnValue(true);
      component.isLastPair = true;

      expect(component.getFeedbackAudioHighlightClass()).toBe('');
    }
  );

  it('should determine if a string is a number', () => {
    let number = '-12.4';
    expect(component.isStringifiedNumber(number)).toEqual(true);
    number = 'ab12';
    expect(component.isStringifiedNumber(number)).toEqual(false);
  });

  it('should convert answer to a local format if it is a number', () => {
    spyOn(numberConversionService, 'currentDecimalSeparator').and.returnValues(
      ',',
      '.'
    );

    let number = '12.2';
    expect(component.convertAnswerToLocalFormat(number)).toEqual('12,2');
    number = 'abc';
    expect(component.convertAnswerToLocalFormat(number)).toEqual('abc');
    number = '-12.3';
    expect(component.convertAnswerToLocalFormat(number)).toEqual('-12.3');
  });

  it('should show solution button if solution is released', () => {
    spyOn(hintsAndSolutionManagerService, 'isSolutionViewable').and.returnValue(
      true
    );

    expect(component.isSolutionButtonVisible()).toBe(true);
  });

  it('should show solution button if solution is released', () => {
    spyOn(hintsAndSolutionManagerService, 'isSolutionViewable').and.returnValue(
      true
    );

    expect(component.isSolutionButtonVisible()).toBe(true);
  });

  it('should not show solution button if solution is not released', () => {
    spyOn(hintsAndSolutionManagerService, 'isSolutionViewable').and.returnValue(
      false
    );

    expect(component.isSolutionButtonVisible()).toBe(false);
  });

  it(
    'should display solution modal if solution is' + ' already consumed',
    fakeAsync(() => {
      spyOn(
        hintsAndSolutionManagerService,
        'isSolutionConsumed'
      ).and.returnValue(true);
      spyOn(
        hintAndSolutionModalService,
        'displaySolutionModal'
      ).and.returnValue({
        result: Promise.resolve('success'),
      } as NgbModalRef);

      expect(component.solutionModalIsActive).toBe(false);

      component.onClickSolutionButton();
      tick();

      expect(component.solutionModalIsActive).toBe(true);
    })
  );

  it('should close solution modal', fakeAsync(() => {
    spyOn(hintsAndSolutionManagerService, 'isSolutionConsumed').and.returnValue(
      true
    );
    spyOn(hintAndSolutionModalService, 'displaySolutionModal').and.returnValue({
      result: Promise.reject(),
    } as NgbModalRef);

    component.onClickSolutionButton();
    tick();

    expect(component.solutionModalIsActive).toBe(false);
  }));

  it(
    'should open interstitial modal if solution has not' +
      ' been consumed before and then display solution modal' +
      ' after user confirms',
    fakeAsync(() => {
      spyOn(
        hintsAndSolutionManagerService,
        'isSolutionConsumed'
      ).and.returnValue(false);
      spyOn(
        hintAndSolutionModalService,
        'displaySolutionInterstitialModal'
      ).and.returnValue({
        result: Promise.resolve('success'),
      } as NgbModalRef);
      spyOn(component, 'displaySolutionModal').and.callFake(() => {});

      component.onClickSolutionButton();
      tick();

      expect(component.displaySolutionModal).toHaveBeenCalled();
    })
  );

  it(
    'should close interstitial modal if solution has not' +
      ' been consumed before and user click cancel',
    fakeAsync(() => {
      spyOn(
        hintsAndSolutionManagerService,
        'isSolutionConsumed'
      ).and.returnValue(false);
      spyOn(
        hintAndSolutionModalService,
        'displaySolutionInterstitialModal'
      ).and.returnValue({
        result: Promise.reject('failure'),
      } as NgbModalRef);
      spyOn(component, 'displaySolutionModal').and.callFake(() => {});

      component.solutionModalIsActive = true;
      component.onClickSolutionButton();
      tick();

      expect(component.solutionModalIsActive).toBe(false);
      expect(component.displaySolutionModal).not.toHaveBeenCalled();
    })
  );

  it('should show solution is consumed or not', () => {
    spyOn(
      hintsAndSolutionManagerService,
      'isSolutionConsumed'
    ).and.returnValues(true, false);

    expect(component.isSolutionConsumed()).toBe(true);
    expect(component.isSolutionConsumed()).toBe(false);
  });

  it('should check if the solution is released', () => {
    spyOn(hintsAndSolutionManagerService, 'isSolutionReleased').and.returnValue(
      true
    );

    expect(component.isSolutionReleased()).toBe(true);
  });

  it('should check if the solution is not released', () => {
    spyOn(hintsAndSolutionManagerService, 'isSolutionReleased').and.returnValue(
      false
    );

    expect(component.isSolutionReleased()).toBe(false);
  });
});
